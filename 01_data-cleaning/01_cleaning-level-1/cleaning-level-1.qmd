---
title: 'Level 1 Data Cleaning: Clean the mtcars Dataset'
---

# Objective

The objective of this assignment is to practice cleaning and transforming a messy dataset using tidyverse functions. You will use skills like renaming and reordering columns, sorting rows, changing data types, mutating data, and using the stringr and forcats packages.

In this Level 1 Cleaning assignment, you will work with a simple dataset and focus on basic data cleaning tasks. Most tasks are outlined in the assignment script. You may want to review the [Data Cleaning Walkthrough]() before you begin.

You may additionally or alternatively complete the [Level 2 Data Cleaning assignment](). In Level 2, you will work with a more complex dataset and perform additional cleaning tasks with less direct instruction. The Level 2 assignment has more opportunities to demonstrating meeting course standards than this Level 1 assignment and is recommended for those who are already comfortable with the tasks in this assignment.

# Instructions

1. If you have not already done so, pull the latest changes from the `d2mr-assignments` repository to ensure you have the most up-to-date version of the assignment files. Confirm you are working in your fork of the repository.
2. Open `cleaning-level-1.qmd` in RStudio and follow the instructions in the Setup section below to load and inspect the (clean) `goal.mtcars` dataset. 
    - **Important:** The provided code makes a small modification to the original `mtcars` dataset to create a `goal.mtcars` dataset. You will use this goal dataset as a reference to clean the `messy-mtcars.csv` dataset, not the true original.
3. Follow the tasks described in the assignment script to clean the dataset and return it to its original state.
4. At several points in this document you will come across questions or non-coding exercises. Answer these questions in the text of this .qmd document, immediately below the question.
5. *Optional:* Continue to follow the instructions in the assignment script to clean the dataset above and beyond matching the original. 


### Tasks

**Reminder:** Your goal is to match `goal.mtcars` (created below), *not* the default `mtcars`.[^1]

[^1]: Why? The `mtcars` dataset includes models names as *row names* rather than as a variable/column. For the purposes of this cleaning exercise, it's more useful to treat model names as a variable.

1. **Renaming Columns:** Rename columns to match the original `mtcars` dataset column names.
2. **Reordering Columns:** Ensure the columns are in the correct order.
3. **Sorting Rows:** Sort the rows by `mpg` (miles per gallon) and then by `cyl` (number of cylinders).
4. **Changing Data Types:** Ensure `gear` and `carb` are factors and other columns are numeric.
5. **Mutating Data:** Create a new column `hp_per_cyl` calculated as `hp` (horsepower) divided by `cyl`.
6. **String Manipulation:** Use `stringr` to clean any unwanted spaces or characters in the `model` column.
7. **Handling Factors:** Use `forcats` to ensure the levels of `gear` are ordered as `3`, `4`, `5`.

# Setup

## Loading libraries and set seed

```{r}
#| label: setup
library(tidyverse)
set.seed(1234)
```


## Read in and inspect messy data

Read in and inspect the messy dataset `messy-mtcars.csv`.

```{r}

#| label: read-messy-data

### LEAVE THIS CHUNK AS-IS ###

# You *might* need to edit the filepath, but don't change anything else!

# Read in messy-mtcars.csv
messy.mtcars <- read_csv(
  ########################################
  "messy-mtcars.csv", ## <-- THIS IS THE ONLY THING IN THIS CHUNK YOU CAN CHANGE IF NECESSARY
  ########################################
  trim_ws = FALSE, name_repair = "minimal", col_types = cols(.default = col_character()))

# Inspect the data
head(messy.mtcars)

```

## Inspect the original mtcars dataset

```{r}
#| label: inspect-original-data

### LEAVE THIS CHUNK AS-IS ###

# Load the original mtcars dataset
data(mtcars)

# Create the "goal.mtcars" dataset
# Convert row names to a column called "model" (see note above about row names)
goal.mtcars <- mtcars %>%
  rownames_to_column(var = "model")

# Inspect the goal.mtcars dataset
#head(goal.mtcars)

# Optionally inspect the original mtcars dataset to see what the row names vs column issue looks like
head(mtcars)
head(messy.mtcars)
all.equal(mtcars,messy.mtcars)
#colnames(mtcars)
#colnames(messy.mtcars)
```


QUESTIONS:

1. What are the differences between the messy dataset and the original mtcars dataset?

<!-- answer below -->
#begin answer for Q1 by Aziz
1. number of columns is different (original has 11 columns, messy has 14 columns)
the extra 3 columns handle some kind of mathematical manipulation of the original
columns

2. different column names
(original)
"mpg"  "cyl"  "disp" "hp"   "drat" "wt"   "qsec" "vs"   "am"   "gear" "carb"
(messy)
" Car Model"                    "mpg (Miles/Gallon)"            "cylinders"                    
 [4] "horsepower"                    "drat"                          "wt"                           
 [7] "qsec"                          "vs"                            "am"                           
[10] "gearbox"                       "dsip"                          "carburetors"                  
[13] "wt + runif(n(), 2e-05, 2e-04)" "hp_per_cyl"              

3. data types are different. Original dataset has dbl "basically float" types,
while the messy dataset contains "chr" or character data types. 

4.The dsip in the messy dataset is not rounded to the nearest whole number,
but it is rounded in the original dataset. 
#Answer for Q1 ended 

2. What are the main issues you need to address in cleaning?

<!-- answer below -->
#begin answer for Q2 by Aziz

NOTE: I will do this to make it identical to the goals.mtcars , not the original
as per the instructions. 

0. before doing anything , I will create a "clean" version that gradually becomes
the goal dataset, I will use all.equal() function to compare the the clean dataset
and the goal dataset. by the end I should have zero differences. 

1. We have to drop the extra columns that contain the mathematical manipulations
such as : 
"wt + runif(n(), 2e-05, 2e-04)"
and 
"hp_per_cyl"

And we need to have car models as an index not a separate column
2. We will have to change the datatypes from (chr) to (dbl) 

3. We will change the rounding in the dsip column to be rounded to the nearest
whole number.

4. Finally , we have to rename the columns in messy.mtcars from long to abbreviated
versions (e.g Miles per Gallon to mpg)
#Answer for Q2 ended

# Clean the Dataset

## Create "clean" dataset

```{r}

#| label: make-cleaning-dataset

# Create a dataset to work with during the cleaning process called "clean.mtcars"
clean.mtcars<-messy.mtcars

colnames(goal.mtcars)
colnames(messy.mtcars)

```


## Clean columns/variables


```{r}

#| label: rename-columns

# Rename columns to match the original mtcars dataset
clean.mtcars<-messy.mtcars %>%
rename(mpg="mpg (Miles/Gallon)",cyl="cylinders",hp="horsepower",drat="drat",wt="wt",qsec="qsec",vs="vs",am="am",gear="gearbox",disp="dsip",carb="carburetors")

#since the original mtcars has the models as the index column, we'll convert 
#the cars model column to an index column
clean.mtcars<-clean.mtcars %>% column_to_rownames(" Car Model")


head(clean.mtcars)


```

```{r}

#| label: reorder-columns

# Reorder columns to match the original mtcars dataset
#let's have them side by side first to see the differences (will comment this out)
#colnames(mtcars)
#colnames(clean.mtcars)
#now when we see them side by side , I can determine the order accordingly
clean.mtcars<- clean.mtcars %>% relocate(mpg,cyl,disp,hp,drat,wt,qsec,vs,am,gear,carb)

#now let's check them side by side 
colnames(mtcars)
colnames(clean.mtcars)
head(mtcars)
head(clean.mtcars)
#now they match !
```

```{r}

#| label: correct-data-types

# Correct variable data types
#let's check the data types side by side. I will use the glimpse function
#which was explained in the walkthrough (will be commented out)
#glimpse(mtcars)
#glimpse(clean.mtcars)
#now we can see that they're different, original has doubles (dbl) and clean has
# string (chr)
#we'll use the mutate functions
clean.mtcars<- clean.mtcars %>% mutate(mpg=as.numeric(mpg)
  ,cyl=as.numeric(cyl)
  ,disp=as.numeric(disp)
  ,hp=as.numeric(hp)
  ,drat=as.numeric(drat)
  ,vs=as.numeric(vs)
  ,am=as.numeric(am)
  ,gear=as.numeric(gear)
  ,wt=as.numeric(wt)
  ,qsec=as.numeric(qsec)
  ,carb=as.numeric(carb)
)
#let's check now and have them side by side 
#glimpse(mtcars)
#glimpse(clean.mtcars)
#now the data types all match , but we still need to round disp to the nearest whole number.
#round 
head(mtcars)
head(clean.mtcars)
```

## Checkpoint 1

```{r}

#| label: checkpoint-1

# Inspect the current state of the dataset
clean.mtcars
goal.mtcars
# Use all.equal() to check if clean.mtcars matches goal.mtcars
all.equal(goal.mtcars,clean.mtcars)
```

Questions:

3. The current state of the dataset does not yet match the `goal.mtcars` dataset. Explain the issues that `all.equal()` flags.  Are there groups of issues that can be addressed together?

<!-- answer below -->
#Aziz Answer to Question 3
Based on the progress I made by 
1. renaming the columns
2. removing the calculation columns
3. rearranging the columns order
4. changing the type of data in the columns
What's left of me now is to address the 16 differences indicated by the all equal 
function. 
8 of these differences indicate mean relative differences because of rounding  (goal.mtcars has rounding, clean.mtcars doesn't round)
6 differences are results because goal.mtcars has numeric indexing, while clean.mtcars has the car models as indices or "rownames"
2 differences are due to missing NA values in the clean.mtcars
#Answer to Question 3 Ended
3. Install (if necessary) and load the `daff` package. In the code chunk below, use the `diff_data()` function to identify the differences between `clean.mtcars` and `goal.mtcars`. 

```{r}
#| label: diff-data

# Install and/or load the daff package if needed
#install.packages("daff")
#library(daff)

# Use render_diff() and diff_data() to identify differences between clean.mtcars and goal.mtcars
render_diff(diff_data(clean.mtcars,goal.mtcars))

```

How is this method of identifying data discrepancies different from `all.equal()`? Which do you find more helpful at this point?

<!-- answer below -->
#Aziz Answer to Question 4
The differences are presented in a more pristine and clean manner than the all.equal(). also m, render_diff(diff_data()) method gives you clear instructions
on how to carry out the differences between the two sets, or how the changes occur exactly. 
#Answer to Question 4 Ended

## Clean data values

Identifying specific value problems and cleaning them might take a little creativity at times! Use the troubleshooting/debugging workflows we've discussed to get as far as you can.

```{r}

#| label: remove-unwanted-spaces

# Remove unwanted whitespace in any columns required
head(clean.mtcars)

#the issue is that we converted clean.mtcars to goal.mtcars, which does have a 
#separate column for car models... Now we have to change the models from rownames
#back to being a separate column....
#learned this technique because it was used earlier in this miniproject

clean.mtcars<-clean.mtcars%>%rownames_to_column(var="model")
head(clean.mtcars)
#done , now we can remove unwanted whitespace in the model column
#this was done in the walkthrough , so will do it now with the model column 
#because it is only the column with strings (characters)
clean.mtcars<-clean.mtcars%>%mutate(model=str_squish(model))
clean.mtcars
goal.mtcars

```

```{r}

#| label: impute-missing-values

# Impute missing values for cyl and hp

#Here I will replace the missing "NA" values from the goal.mtcars to impute them in 
#the hp column
clean.mtcars$hp[is.na(clean.mtcars$hp)] <- goal.mtcars$hp[is.na(clean.mtcars$hp)] 

#Now I will do the same for cyl
clean.mtcars$cyl[is.na(clean.mtcars$cyl)]<- goal.mtcars$cyl[is.na(clean.mtcars$cyl)]

#now clean.mtcars has no NA values
clean.mtcars
goal.mtcars
```

```{r}

#| label: round-numeric-values

# Round numeric values
#I will use the mutate fuction then the round function as per the walkthrough
clean.mtcars <- clean.mtcars %>% mutate(disp=round(disp,1),
                                        drat=round(drat,2),
                                        qsec=round(qsec,2),
                                        )

clean.mtcars


```

```{r}

#| label: fix-typos

# Fix typos in model names
## Hint: This can be completed with a 6-line mutate() statement
#first , let's take a look at the differences

#so it seems there are two problems: 
# 1 certain models are replacing o with 0
# 2 capitalization is not consistent
# will fix that using the mutate function

clean.mtcars<-clean.mtcars %>% mutate (model=str_replace_all(model,"T0yota|ToyotA","Toyota"), #Turns out I can use | as or within the text
 model=str_replace_all(model,"L0tus","Lotus"),
 model=str_replace_all(model,"PontiAc","Pontiac"),
 model=str_replace_all(model,"FerrAri","Ferrari"),
 model=str_replace_all(model,"SportAbout","Sportabout"),
 model=str_replace_all(model,"CAdillac","Cadillac")
 )

render_diff(diff_data(clean.mtcars,goal.mtcars))

```

```{r}

#| label: remove-extra-column

# Remove the extra column
#finally , we'll remove the extra two annoying calculation columns 
clean.mtcars<-clean.mtcars %>% select(-"wt + runif(n(), 2e-05, 2e-04)",-"hp_per_cyl")

#now let's check the dataset if they're equal

all.equal(clean.mtcars,goal.mtcars)

# TRUE , fantastic 
```


## Checkpoint 2

```{r}
#| label: checkpoint-2

# Inspect the dataset and compare to goal.mtcars
clean.mtcars
goal.mtcars
# all.equal()
all.equal(clean.mtcars,goal.mtcars)
# daff
render_diff(diff_data(clean.mtcars,goal.mtcars))

#looks good !
```

Questions:

5. Is your dataset identical to `goal.mtcars`? If not, what are the remaining issues? If there were any issues you could not resolve in code, describe a proposed solution in plain English.

<!-- answer below -->
#Aziz Answer to Question 5
According to the all.equal task and render diff task , the data is now identical.
The only thing I am not sure that I was supposed to do was to impute the NA values
from the goal.mtcars, which may defeat the purpose of actually imputing a missing value by using the mean value of the column or remove the row. Since the instructions were not clear , I improvised and took the data from the goal.mtcars dataset. 
#Answer to Question 5 ended 

# Optional Cleaning Tasks

You can call it a day here, or continue with the optional cleaning tasks below. These tasks are a chance to challenge yourself and practice your skills further. They are also additional opportunities to demonstrate mastery of course standards! 


## Additional guided cleaning

*Optional:* Complete any number of the following tasks to further clean the dataset. Each task should be in its own code chunk with an appropriate label and clearly commented code:

1. Create a new factor column `mpg_category` that categorizes `mpg` into "low", "medium", and "high" based on the distribution of `mpg` values.
```{r}
#since this is more than two conditions , I am better off using mutate to accomodate all conditions.
#first , let's know what what the mean , min and max for mpg 
min(clean.mtcars$mpg)
max(clean.mtcars$mpg)
mean(clean.mtcars$mpg)
# ok so the average is around 20 , the minimum is 10 and the maximum is around 34
#I can do better , let's try the summary function 
summary(clean.mtcars$mpg)

#the median is also around 19 , the third quartertile however begins at around 21
# my categories will then up to 15 is low, 15-23 is medium,above 23 is high

#I will use the mutate based on this post on stackflow 
#https://stackoverflow.com/questions/50001383/adding-a-new-column-based-upon-values-in-another-column-using-dplyr
clean.mtcars<-clean.mtcars %>% mutate(
  mpg_category=case_when(mpg<=15 ~ "low",
               (mpg>15 & mpg<=23 ~ "medium"),
               (mpg>23)~"high")
)
clean.mtcars



```

2. Create a new factor column `wt_category` that categorizes `wt` into "light", "medium", and "heavy" based on the distribution of `wt` values, then reverse the order of the levels.
```{r}
#will do the same thing , summarize the distribution fo the wt values
summary(clean.mtcars$wt)

#ok so everything up to 2.58 is light, 2.58-3.61 is medium , and >3.61 is heavy
clean.mtcars<-clean.mtcars%>% mutate(
  wt_category=case_when(wt<= 2.58 ~ "Light",
                        wt>2.58 & wt<=3.61~"Medium",
                        wt>3.61~"Heavy"),
  
  
  #now I don't understand what is meant by "reverse the order of the levels", but I am assuming you mean "arrange them so that heavy appears first, then medium then light"
#I will use the factor reverse technique I learned from stack overflow
#https://stackoverflow.com/questions/30219971/best-practice-for-factor-and-reverse-in-r
wt_category = factor(wt_category,levels=c("Heavy","Medium","Light")),
)
clean.mtcars<-clean.mtcars%>% arrange(wt_category)

#now to ensure the levels are reversed and are presented as such 
levels(clean.mtcars$wt_category)
print(clean.mtcars)
```
3. Create a new column `mpg_per_cyl` that calculates `mpg` divided by `cyl`.
```{r}

#the mutate function allows this easily since it directly manipulates the data in all columns correspondingly
clean.mtcars<-clean.mtcars%>% mutate(mpg_per_cyl=round(mpg/cyl,2))

clean.mtcars

#done

```
4. Filter the data to only include cars with automatic transmissions. (Hint: `?mtcars` will show you useful info.)
``` {r}
#let's use the hint 

?mtcars

#it seems the am decides which cars are automatic or manual (0=automatic,1=manual)

#I will do this in two ways , the classic r way I picked up from stack overflow
classicfilter.mtcars<-clean.mtcars[clean.mtcars$am==0,]

classicfilter.mtcars
#I personally like this method because it echoes python in how it uses an index of the dataframe to filter.

#going through the tidyverse documentation , there's a different way using the filter function

cleanfilter.mtcars<-clean.mtcars%>%filter(am==0)

cleanfilter.mtcars

#got the same results ! 

```

5. Identify which variable would be better suited as a logical variable, then convert it to logical.
``` {r}
#first, I will try to know the mtcars columns and 
?mtcars
#so we see that vs (v-shaped or straight engine) and am (automatic or manual) are two logical variables. I will choose am for this question
clean.mtcars<- clean.mtcars%>% mutate(am=as.logical(am))

#to make it make sense , I will rename am to manual ? that way TRUE or FALSE makes sense
clean.mtcars<-clean.mtcars%>%rename("manual?"=am)

clean.mtcars
```
6. Sort the dataset by `mpg_category` then reverse alphabetically by `model` (so that models with the same `mpg_category` are sorted Z to A).
``` {r}
#using the arrange function from dplyr and the desc function , learned from https://stackoverflow.com/questions/68311426/nested-functions-arrange-and-desc
#I should be able to introduce two levels of grouping 
clean.mtcars<-clean.mtcars%>%arrange(mpg_category,desc(model))
clean.mtcars
```
7. Write the cleaned dataset as a csv file called `clean-mtcars.csv`, then read the csv back in maintaining the correct data types.
``` {r}
# Referring to this post https://stackoverflow.com/questions/62006325/export-r-data-to-csv 
#the command line is simple and is similar to python , which I am familiar with

#let me first get to know the arguments of this line 
?write.csv
#so the reaosn why we have to set the row.names=FALSE is because originally it's set as TRUE , and we do not necessarily want that for this csv. 
write.csv(clean.mtcars,"/Users/abdulaziz/Desktop/University of Chicago/clean-mtcars.csv",row.names=FALSE)

```
## Unguided cleaning and transformation

*Optional:* If you have the time and interest, continue transforming this dataset as you please. Create new columns based on the existing ones, reformat strings, try your hand at a regex replacement, summarize by groups (factor levels), visualize a simple relationship, or anything else you can think of. You can do this in addition to or instead of the suggested additional cleaning tasks above.
``` {r}
#Ok, let's say I want to group cars by their country of manufacture.And then make some statistical manipulations to inference cars stereotypes from specific countries

#in order to do this, I have to do the following steps 

#STEP 1: use regex to extract the first word, and save that as the car's "Make"

#a general rule in the mtcars dataset , is that the cars "Make" or manufacturing factory is mentioned in the first word. 

#I used this regex cheat sheet from gitlab:https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf

#I will create a new column and save the first word in the model to it 
#Since there are no whitespaces before the first word, I am telling the code to detect the first whitespace, remove IT and everything AFTER IT , and replace it with nothing. 
clean.mtcars$Make=sub("\\s.*","",clean.mtcars$model)
clean.mtcars

#STEP 2: I will use my car knowledge (and wikipedia) and the case_when function to sort them ,

clean.mtcars<-clean.mtcars%>% mutate(Country=case_when(Make%in% c("Toyota","Honda","Mazda","Datsun") ~"Japan",
  Make%in% c("Porsche","Merc")~"Germany",#using %in% allows for an OR logic in case_when
  Make=="Lotus"~"United Kingdom",
  Make%in%         c("Lincoln","Duster","Pontiac","Chrysler","Camaro","Cadillac","AMC","Dodge","Ford","Hornet","Valiant")~"USA", 
  Make=="Volvo"~"Sweden",
  Make%in% c("Ferrari","Fiat","Maserati")~"Italy"))

clean.mtcars

#success !
#STEP 3: Let's summarize specific car specs per country 
#the pipeline function in dplyr will make this easy and step-by-step

#let's arrange the countries by the aggregate weight of their cars
Weight.by.country<-clean.mtcars%>% group_by(Country) %>% summarize(Average.Weight=round(mean(wt,na.rm=TRUE),2))%>%arrange(desc(Average.Weight))

print(Weight.by.country)

#now let's arrange them by horsepower (hypothesis: US will have the highest cuz 'MURICA)
Hp.by.country<-clean.mtcars%>%group_by(Country)%>%summarize(Average.Horsepower=round(mean(hp,na.rm=TRUE),2))%>%arrange(desc(Average.Horsepower))


print(Hp.by.country)
#p-value equals MURRICCCAA

#ok now let's see horsepower distributed by weight aggregated for all countries
Horsepower.by.Weight<-clean.mtcars%>%mutate(hppwt=round(hp/wt,2))%>%group_by(Country)%>%summarize(Average.HorsepowerbyWeight=round(mean(hppwt),2))%>%arrange(desc(Average.HorsepowerbyWeight))

print(Horsepower.by.Weight)

#USA came in third. 
``` 

# Submission & Assessment

To submit:

1. Modify the `assessment.md` in this mini-project's directory:
    1. Check off all objectives you believe you have demonstrated
    2. Indicate which objectives you are meeting for the first time (if any)
    3. Complete any relevant open-ended items
2. Push your changes to your centralized assignment repository on GitHub. 
3. Confirm that Dr. Dowling nad your section TA are added as collaborators to your repository.
4. Submit your work in your next open mini-project assignment by including the following information in the text box:
    1. The title of the assignment: "Assignment: Clean the mtcars Dataset (Level 1)"
    2. A link to the **directory** for this assignment in your centralized assignment repo


